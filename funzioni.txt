HEADERS:üòÉÔ∏è
#include <unistd.h>     per fork(), getpid(), getppid(), sleep(), execlp(), read(), write(), close()
#include <sys/wait.h>   per wait() e waitpid()
#include <sys/stat.h>   per S_IRUSR e S_IWUSR
#include <sys/ipc.h>    per IPC_PRIVATE e IPC_RMID
#include <sys/shm.h>    per shmget(), shmat(), shmdt(), shmctl()
#include <sys/types.h>  per pid_t, pthread_t, pthread_attr_t, ecc...
#include <pthread.h>    per le funzioni su thread e mutex

PROCESSI:üòÉÔ∏è
pid_t      fork()
	   wait(NULL)
	   sleep(sec)
	   usleep(microsec)
int	   getpid()   -> (pid effettivo del processo corrente)
int   	   getppid()  -> (pid effettivo del processo padre del processo corrente)
	   execlp(char*pathname, char*arg0, char*arg1, ..., NULL)	   

MEMORIA CONDIVISA:üòÉÔ∏è
segment_id= shmget(IPC_PRIVATE, MAX_SIZE, S_IRUSR|S_IWUSR)  -> (<0, id)
ptr=  (cast)shmat(segment_id, NULL, 0)           -> ((void*)-1, void* ptr)
            shmdt(ptr)                           -> (-1, 0)
            shmctl(segment_id, IPC_RMID, NULL)   -> (-1, 0)                  
            
SCAMBIO DI MESSAGGI:üòÉÔ∏è
int verifica= pipe(fd)  -> (-1, 0)
              close(fd) 
int inviati=  write(fd[1], message_ptr, size)  -> ( <size,  numero_byte_inviati )
int ricevuti= read(fd[0], message_ptr, size)   -> ( -1, <size, 0)

THREADS:üòÉÔ∏è
pthread_t  tid
	   pthread_create( &tid, NULL, thread_func, arg_ptr)  -> (!=0, 0)
void*	   thread_func(void* arg)  ->(NULL, altro)
	   pthread_exit(void* result_ptr)
	   pthread_join(tid, void** result_ptr)
	   
MUTEX E VARIABILI CONDITION:üòÉÔ∏è
pthread_mutex_t nomeMutex; //Dichiaro il mutex
pthread_cond_t nomeVariabileCondition; //Dichiaro la variabile condition.
pthread_mutex_init(&mutex, NULL); //inizializzo il mutex con attributi di default; restituisce 0 in
caso di successo. √à possibile inizializzare il mutex durante la dichiarazione, attraverso la macro
PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_lock(&mutex); //Acquisisco il mutex, se era gi√† occupato il thread viene sospeso
finch√© il mutex non si libera. Restituisce 0 in caso di successo.
pthread_mutex_unlock(&mutex); //Rilascio il mutex, restituisce 0 in caso di successo.
pthread_mutex_destroy(&mutex); //Distruggo il mutex, restituisce 0 in caso di successo.
pthread_cond_init(&varcond, NULL); //inizializzo la variabile condition con attributi di default;
restituisce 0 in caso di successo. √à possibile inizializzare la variabile condition durante la
dichiarazione, attraverso la macro PTHREAD_COND_INITIALIZER;
pthread_cond_destroy(&varcond); //Distruggo la variabile condition, restituisce 0 in caso di
successo
pthread_cond_wait(&varcond, &mutex); //Effettua la wait sulla variabile condition, restituisce 0 in
caso di successo.
pthread_cond_signal(&varcond); //Effettua la signal sulla variabile condition (sveglia un solo
thread), restituisce 0 in caso di successo.
pthread_cond_broadcast(&varcond); //Effettua la broadcast sulla variabile condition (sveglia tutti i
thread), restituisce 0 in caso di successo.
